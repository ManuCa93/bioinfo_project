---
title: "Bioinformatics Project - Bulk RNA-seq Differential Expression Analysis"
author: "Bidiscombe, Carnevale, Cattoni"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 10, fig.height = 6)
```

# 1. Introduction and Biological Question

## Biological Context

Lung adenocarcinoma (LUAD) is the most common subtype of lung cancer and a leading cause of cancer-related deaths worldwide. Understanding the molecular changes that occur during tumorigenesis is crucial for identifying potential therapeutic targets and biomarkers.

## Computational Question

*What genes are differentially expressed between primary tumor tissue and adjacent normal tissue in lung adenocarcinoma patients?*

This analysis will help identify:

-   Genes upregulated in tumors (potential oncogenes or tumor-promoting factors)
-   Genes downregulated in tumors (potential tumor suppressors)
-   Biological pathways disrupted in lung cancer

# 2. Data Loading and Preprocessing

```{r load_packages}
# Load required libraries
# Note: If any package is missing, install it first with:
# BiocManager::install(c("recount3", "edgeR", "limma", "pheatmap", "org.Hs.eg.db", "clusterProfiler"))

suppressPackageStartupMessages({
  library(recount3)
  library(SummarizedExperiment)
  library(edgeR)
  library(limma)
  library(ggplot2)
  library(pheatmap)
  library(dplyr)
  library(tibble)
})

cat("All packages loaded successfully!\n")
```

## 2.1 Download TCGA-LUAD Data from recount3

```{r load_data}
# List available projects
projects <- available_projects()

# Filter for TCGA projects
tcga_projects <- subset(projects, file_source == "tcga")

# Select LUAD (Lung Adenocarcinoma) project
projinfo_luad <- subset(tcga_projects, project == "LUAD")
print(projinfo_luad)

# Download the RangedSummarizedExperiment object
rse_gene <- create_rse(projinfo_luad)

# Extract count matrix and sample metadata
counts  <- assay(rse_gene, "raw_counts")
coldata <- colData(rse_gene)

cat("Dataset dimensions:", dim(counts)[1], "genes x", dim(counts)[2], "samples\n")
```

## 2.2 Filter for Tumor vs Normal Comparison

```{r filter_samples}
# Check available sample types
sample_type <- coldata$tcga.gdc_cases.samples.sample_type
cat("Available sample types:\n")
print(table(sample_type))

# Keep only Primary Tumor and Solid Tissue Normal
keep <- sample_type %in% c("Primary Tumor", "Solid Tissue Normal")
rse_gene_sub <- rse_gene[, keep]

counts_sub  <- assay(rse_gene_sub, "raw_counts")
coldata_sub <- as.data.frame(colData(rse_gene_sub))

cat("\nFiltered dataset:", dim(counts_sub)[1], "genes x", dim(counts_sub)[2], "samples\n")
cat("\nSample distribution:\n")
print(table(coldata_sub$tcga.gdc_cases.samples.sample_type))
```

## 2.3 Create Condition Variable

```{r create_condition}
# Create binary condition variable
condition <- ifelse(
  coldata_sub$tcga.gdc_cases.samples.sample_type == "Primary Tumor",
  "tumor",
  "normal"
)
coldata_sub$condition <- factor(condition, levels = c("normal", "tumor"))

cat("Final sample distribution:\n")
print(table(coldata_sub$condition))
```

## 2.4 Data Quality Control with CPM Filtering

```{r qc_filtering}
# Calculate CPM (Counts Per Million)
cpm_values <- cpm(counts_sub)

# Determine the size of the smallest group
min_group_size <- min(table(coldata_sub$condition))

# Keep genes with CPM > 0.5 in at least min_group_size samples
keep_genes <- rowSums(cpm_values > 0.5) >= min_group_size
counts_filtered <- counts_sub[keep_genes, ]

cat("Genes before filtering:", nrow(counts_sub), "\n")
cat("Genes after filtering:", nrow(counts_filtered), "\n")
cat("Genes removed:", nrow(counts_sub) - nrow(counts_filtered), "\n")
cat("Filtering criterion: CPM > 0.5 in at least", min_group_size, "samples\n")
```

# 3. Differential Expression Analysis with edgeR

## 3.1 Create DGEList Object

```{r create_dgelist}
# Prepare sample metadata for edgeR
sample_info <- data.frame(
  condition = coldata_sub$condition,
  row.names = colnames(counts_filtered)
)

# Create DGEList object
dge <- DGEList(counts = counts_filtered, group = sample_info$condition)

cat("DGEList object created with", nrow(dge), "genes and", ncol(dge), "samples\n")
cat("\nLibrary sizes:\n")
print(summary(dge$samples$lib.size))
```

## 3.2 Normalization

```{r normalization}
# Calculate normalization factors using TMM (Trimmed Mean of M-values)
dge <- calcNormFactors(dge, method = "TMM")

cat("Normalization factors calculated:\n")
print(summary(dge$samples$norm.factors))

# Visualize normalization factors
barplot(dge$samples$norm.factors, 
        main = "TMM Normalization Factors",
        ylab = "Normalization Factor",
        xlab = "Sample Index",
        col = ifelse(dge$samples$group == "tumor", "red3", "forestgreen"),
        las = 2)
abline(h = 1, lty = 2, col = "blue")
legend("topright", legend = c("Tumor", "Normal"), 
       fill = c("red3", "forestgreen"), bty = "n")
```

*Interpretation:* TMM normalization accounts for differences in library composition between samples. Normalization factors close to 1 indicate similar library compositions, while deviations suggest compositional biases that are corrected.

## 3.3 Design Matrix and Dispersion Estimation

```{r design_dispersion}
# Create design matrix
design <- model.matrix(~ condition, data = sample_info)
colnames(design) <- c("Intercept", "TumorvNormal")

cat("Design matrix:\n")
print(head(design))

# Estimate dispersion
dge <- estimateDisp(dge, design, robust = TRUE)

cat("\nDispersion estimates:\n")
cat("  Common dispersion:", dge$common.dispersion, "\n")
cat("  Trended dispersion range:", range(dge$trended.dispersion), "\n")
cat("  Tagwise dispersion range:", range(dge$tagwise.dispersion), "\n")

# Plot biological coefficient of variation
plotBCV(dge, main = "Biological Coefficient of Variation")
```

*Interpretation:* The BCV plot shows the biological variability in gene expression. The common dispersion represents the overall variability, while tagwise dispersions capture gene-specific variation. Higher BCV indicates greater biological variability between replicates.

## 3.4 Differential Expression Testing

```{r glm_testing}
# Fit generalized linear model
fit <- glmFit(dge, design)

# Perform likelihood ratio test for tumor vs normal
lrt <- glmLRT(fit, coef = "TumorvNormal")

# Extract results
res <- topTags(lrt, n = Inf)
res_df <- as.data.frame(res)

cat("edgeR analysis summary:\n")
cat("Total genes tested:", nrow(res_df), "\n")
cat("Genes with FDR < 0.05:", sum(res_df$FDR < 0.05), "\n")
```

## 3.5 Process Results

```{r process_results}
# Convert to dataframe and add gene names
res_df <- res_df %>%
  rownames_to_column("gene_id") %>%
  arrange(FDR)

# Add significance labels
res_df <- res_df %>%
  mutate(
    significance = case_when(
      is.na(FDR) ~ "Not tested",
      FDR < 0.05 & abs(logFC) >= 1 ~ "Significant",
      TRUE ~ "Not significant"
    ),
    direction = case_when(
      FDR < 0.05 & logFC >= 1 ~ "Upregulated",
      FDR < 0.05 & logFC <= -1 ~ "Downregulated",
      TRUE ~ "Not significant"
    )
  )

# Summary statistics
cat("\nNumber of differentially expressed genes (FDR < 0.05, |logFC| >= 1):\n")
print(table(res_df$direction))

# Top 10 upregulated genes
cat("\n=== Top 10 Upregulated Genes in Tumors ===\n")
top_up <- res_df %>%
  filter(direction == "Upregulated") %>%
  arrange(desc(logFC)) %>%
  head(10)
print(top_up[, c("gene_id", "logFC", "FDR")])

# Top 10 downregulated genes
cat("\n=== Top 10 Downregulated Genes in Tumors ===\n")
top_down <- res_df %>%
  filter(direction == "Downregulated") %>%
  arrange(logFC) %>%
  head(10)
print(top_down[, c("gene_id", "logFC", "FDR")])
```

# 4. Visualization

## 4.1 MA Plot

```{r ma_plot}
# MA plot showing relationship between mean expression and log fold change
plotMD(lrt, main = "MA Plot: Tumor vs Normal")
abline(h = c(-1, 1), col = "blue", lty = 2)
```

*Interpretation:* The MA plot shows the log2 fold changes (y-axis) versus the average log2 counts per million (x-axis). Red points indicate significantly differentially expressed genes (FDR \< 0.05). Genes with higher average expression tend to have more reliable fold change estimates.

## 4.2 Volcano Plot

```{r volcano_plot}
# Create volcano plot
ggplot(res_df, aes(x = logFC, y = -log10(FDR))) +
  geom_point(aes(color = direction), alpha = 0.6, size = 1.5) +
  scale_color_manual(values = c("Upregulated" = "red", 
                                 "Downregulated" = "blue", 
                                 "Not significant" = "gray70")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Differential Expression in LUAD",
    subtitle = "Tumor vs Normal Tissue (edgeR analysis)",
    x = "Log2 Fold Change",
    y = "-Log10 FDR",
    color = "Regulation"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "right"
  )
```

*Interpretation:* The volcano plot visualizes both statistical significance (y-axis) and biological significance (x-axis). Genes in the upper left and right corners are both statistically significant and show large expression changes. The dashed lines represent our thresholds (\|logFC\| ≥ 1 and FDR \< 0.05).

## 4.3 Heatmap of Top Differentially Expressed Genes

```{r heatmap}
# Get top 50 differentially expressed genes
top_genes <- res_df %>%
  filter(significance == "Significant") %>%
  arrange(FDR) %>%
  head(50) %>%
  pull(gene_id)

# Calculate log-CPM values for heatmap
logcpm <- cpm(dge, log = TRUE)
mat <- logcpm[top_genes, ]

# Prepare annotation for columns
annotation_col <- data.frame(
  Condition = coldata_sub$condition,
  row.names = colnames(mat)
)

# Create heatmap
pheatmap(
  mat,
  scale = "row",
  annotation_col = annotation_col,
  show_rownames = TRUE,
  show_colnames = FALSE,
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "complete",
  color = colorRampPalette(c("blue", "white", "red"))(100),
  main = "Top 50 Differentially Expressed Genes",
  fontsize_row = 6
)
```

*Interpretation:* This heatmap shows the expression patterns of the top 50 most significantly differentially expressed genes. Each row represents a gene, each column represents a sample. The samples clearly cluster by tissue type (tumor vs normal), indicating that these genes effectively distinguish between the two conditions.

## 4.4 MDS Plot

```{r mds_plot}
# Multidimensional scaling plot
# Calculate log-CPM with prior count
logcpm_mds <- cpm(dge, log = TRUE, prior.count = 2)

# Perform MDS
mds <- plotMDS(logcpm_mds, plot = FALSE)

# Create dataframe for plotting
mds_data <- data.frame(
  Dim1 = mds$x,
  Dim2 = mds$y,
  condition = coldata_sub$condition
)

# Plot MDS
ggplot(mds_data, aes(x = Dim1, y = Dim2, color = condition)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = c("normal" = "forestgreen", "tumor" = "red3")) +
  labs(
    title = "MDS Plot: Sample Clustering",
    x = "Leading logFC dimension 1",
    y = "Leading logFC dimension 2",
    color = "Tissue Type"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  )
```

*Interpretation:* Multidimensional Scaling (MDS) plot reveals the overall structure of the data based on leading fold changes. The clear separation between tumor and normal samples indicates strong transcriptional differences between tissue types. MDS is analogous to PCA but based on pairwise distances between samples.

# 5. Gene Annotation

## 5.1 Add Gene Symbols and Entrez IDs

```{r biological_context}
# Load annotation library
if (!requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
  BiocManager::install("org.Hs.eg.db")
}
library(org.Hs.eg.db)

# Convert Ensembl IDs to Entrez IDs and gene symbols
# Extract Ensembl ID without version number
res_df$ensembl_id_clean <- sub("\\..*", "", res_df$gene_id)

# Map to Entrez IDs and gene symbols
entrez_map <- mapIds(org.Hs.eg.db, 
                     keys = res_df$ensembl_id_clean,
                     column = "ENTREZID", 
                     keytype = "ENSEMBL",
                     multiVals = "first")

symbol_map <- mapIds(org.Hs.eg.db, 
                     keys = res_df$ensembl_id_clean,
                     column = "SYMBOL", 
                     keytype = "ENSEMBL",
                     multiVals = "first")

# Add to results dataframe
res_df$entrez_id <- entrez_map[res_df$ensembl_id_clean]
res_df$gene_symbol <- symbol_map[res_df$ensembl_id_clean]

# Reorder columns for better readability
res_df <- res_df %>%
  dplyr::select(gene_id, ensembl_id_clean, entrez_id, gene_symbol, 
         logFC, logCPM, LR, PValue, FDR, 
         significance, direction)

cat("\nAnnotation summary:\n")
cat("  - Total genes:", nrow(res_df), "\n")
cat("  - Genes with Entrez ID:", sum(!is.na(res_df$entrez_id)), "\n")
cat("  - Genes with gene symbol:", sum(!is.na(res_df$gene_symbol)), "\n")

# Export results for further analysis
write.csv(res_df, "results_de_genes_LUAD_edgeR.csv", row.names = FALSE)
cat("\nResults exported to: results_de_genes_LUAD_edgeR.csv\n")

# Save top DEGs for pathway analysis
top_degs <- res_df %>%
  filter(significance == "Significant") %>%
  arrange(FDR)
write.csv(top_degs, "LUAD_significant_DEGs_edgeR.csv", row.names = FALSE)
cat("Significant DEGs exported to: LUAD_significant_DEGs_edgeR.csv\n")
```

# 6. GO Enrichment Analysis

## 6.1 Prepare Gene Lists for Enrichment

```{r prepare_gene_lists}
# Load clusterProfiler
if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
  BiocManager::install("clusterProfiler")
}
library(clusterProfiler)

# Get significant upregulated genes
sig_up <- res_df %>%
  filter(direction == "Upregulated", !is.na(entrez_id)) %>%
  pull(entrez_id)

# Get significant downregulated genes
sig_down <- res_df %>%
  filter(direction == "Downregulated", !is.na(entrez_id)) %>%
  pull(entrez_id)

# Get all significant genes
sig_all <- res_df %>%
  filter(significance == "Significant", !is.na(entrez_id)) %>%
  pull(entrez_id)

# Background: all genes tested
background <- res_df %>%
  filter(!is.na(entrez_id)) %>%
  pull(entrez_id)

cat("Genes for enrichment analysis:\n")
cat("  - Upregulated:", length(sig_up), "\n")
cat("  - Downregulated:", length(sig_down), "\n")
cat("  - Total significant:", length(sig_all), "\n")
cat("  - Background:", length(background), "\n")
```

## 6.2 GO Enrichment - All Significant Genes

```{r go_enrichment_all}
# GO enrichment for all significant genes
ego_all <- enrichGO(
  gene = sig_all,
  universe = background,
  OrgDb = org.Hs.eg.db,
  ont = "BP",  # Biological Process
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

cat("\nGO Enrichment Results (All DEGs):\n")
cat("  - Enriched terms:", nrow(ego_all@result), "\n")

if (nrow(ego_all@result) > 0) {
  # Display top 10 enriched terms
  cat("\nTop 10 Enriched GO Terms:\n")
  print(head(ego_all@result[, c("Description", "GeneRatio", "pvalue", "qvalue")], 10))
  
  # Dotplot
  print(dotplot(ego_all, showCategory = 20, title = "GO Enrichment - All DEGs"))
  
  # Barplot
  print(barplot(ego_all, showCategory = 15, title = "Top GO Terms - All DEGs"))
}
```

## 6.3 GO Enrichment - Upregulated Genes

```{r go_enrichment_up}
# GO enrichment for upregulated genes
ego_up <- enrichGO(
  gene = sig_up,
  universe = background,
  OrgDb = org.Hs.eg.db,
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

cat("\nGO Enrichment Results (Upregulated):\n")
cat("  - Enriched terms:", nrow(ego_up@result), "\n")

if (nrow(ego_up@result) > 0) {
  # Display top 10 enriched terms
  cat("\nTop 10 Enriched GO Terms (Upregulated):\n")
  print(head(ego_up@result[, c("Description", "GeneRatio", "pvalue", "qvalue")], 10))
  
  # Dotplot
  print(dotplot(ego_up, showCategory = 20, title = "GO Enrichment - Upregulated Genes"))
  
  # Barplot
  print(barplot(ego_up, showCategory = 15, title = "Top GO Terms - Upregulated"))
}
```

## 6.4 GO Enrichment - Downregulated Genes

```{r go_enrichment_down}
# GO enrichment for downregulated genes
ego_down <- enrichGO(
  gene = sig_down,
  universe = background,
  OrgDb = org.Hs.eg.db,
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2,
  readable = TRUE
)

cat("\nGO Enrichment Results (Downregulated):\n")
cat("  - Enriched terms:", nrow(ego_down@result), "\n")

if (nrow(ego_down@result) > 0) {
  # Display top 10 enriched terms
  cat("\nTop 10 Enriched GO Terms (Downregulated):\n")
  print(head(ego_down@result[, c("Description", "GeneRatio", "pvalue", "qvalue")], 10))
  
  # Dotplot
  print(dotplot(ego_down, showCategory = 20, title = "GO Enrichment - Downregulated Genes"))
  
  # Barplot
  print(barplot(ego_down, showCategory = 15, title = "Top GO Terms - Downregulated"))
}
```

## 6.5 Compare Enrichment Between Up and Down

```{r compare_enrichment}
if (nrow(ego_up@result) > 0 && nrow(ego_down@result) > 0) {
  # Create comparison list
  gene_list <- list(
    Upregulated = sig_up,
    Downregulated = sig_down
  )
  
  # Compare GO enrichment
  compare_go <- compareCluster(
    geneCluster = gene_list,
    fun = "enrichGO",
    OrgDb = org.Hs.eg.db,
    ont = "BP",
    pAdjustMethod = "BH",
    pvalueCutoff = 0.05,
    qvalueCutoff = 0.2
  )
  
  # Dotplot comparison
  print(dotplot(compare_go, showCategory = 10, 
                title = "GO Enrichment Comparison: Up vs Down"))
}
```

*Interpretation:* GO enrichment analysis reveals the biological processes most affected by differential expression. Upregulated genes may be enriched in cell proliferation, DNA replication, and metabolic pathways associated with cancer. Downregulated genes may be enriched in differentiation, immune response, or tumor suppressor pathways.

# 7. Extended Results Analysis

## 7.1 Distribution of Differentially Expressed Genes

```{r deg_distribution}
# Detailed breakdown of DEG categories
cat("=== DIFFERENTIAL EXPRESSION BREAKDOWN ===\n\n")

# Overall statistics
total_tested <- nrow(res_df)
total_sig <- sum(res_df$FDR < 0.05, na.rm = TRUE)
total_sig_fc <- sum(res_df$significance == "Significant", na.rm = TRUE)

cat("Total genes tested:", total_tested, "\n")
cat("Significant genes (FDR < 0.05):", total_sig, 
    sprintf("(%.1f%%)", 100 * total_sig / total_tested), "\n")
cat("Significant with |logFC| >= 1:", total_sig_fc, 
    sprintf("(%.1f%%)", 100 * total_sig_fc / total_tested), "\n\n")

# Direction breakdown
cat("Direction of regulation:\n")
direction_table <- table(res_df$direction)
print(direction_table)
cat("\n")

# Proportion
cat("Proportion upregulated vs downregulated:\n")
up_genes <- sum(res_df$direction == "Upregulated", na.rm = TRUE)
down_genes <- sum(res_df$direction == "Downregulated", na.rm = TRUE)
cat(sprintf("Upregulated: %d (%.1f%%)\n", up_genes, 100 * up_genes / (up_genes + down_genes)))
cat(sprintf("Downregulated: %d (%.1f%%)\n", down_genes, 100 * down_genes / (up_genes + down_genes)))
```

## 7.2 Fold Change Distribution

```{r fc_distribution}
# Distribution of log2 fold changes for significant genes
sig_genes <- res_df %>% filter(significance == "Significant")

cat("\n=== LOG2 FOLD CHANGE STATISTICS (Significant DEGs) ===\n")
print(summary(sig_genes$logFC))

# Visualize fold change distribution
ggplot(sig_genes, aes(x = logFC, fill = direction)) +
  geom_histogram(bins = 50, alpha = 0.7, color = "black") +
  scale_fill_manual(values = c("Upregulated" = "red3", "Downregulated" = "blue3")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribution of Log2 Fold Changes",
    subtitle = "Significant DEGs (FDR < 0.05, |logFC| >= 1)",
    x = "Log2 Fold Change",
    y = "Number of Genes",
    fill = "Direction"
  ) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))
```

*Interpretation:* The distribution shows whether upregulated and downregulated genes have similar magnitude changes. A symmetric distribution suggests balanced regulation, while asymmetry might indicate preferential activation or repression of certain pathways.

## 7.3 P-value Distribution

```{r pvalue_distribution}
# Check p-value distribution (quality control)
ggplot(res_df %>% filter(!is.na(PValue)), aes(x = PValue)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black", alpha = 0.7) +
  labs(
    title = "Distribution of Raw P-values",
    subtitle = "Uniform distribution with enrichment near 0 indicates good data quality",
    x = "Raw P-value",
    y = "Frequency"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9)
  )
```

*Interpretation:* A proper p-value distribution should be relatively uniform across most values (representing null hypotheses) with an enrichment of small p-values near 0 (representing true positives). This pattern confirms our differential expression analysis is working correctly.

# 8. Biological Interpretation Summary

## 8.1 Key Quantitative Findings

```{r final_summary}
cat("\n")
cat("========================================\n")
cat("    FINAL ANALYSIS SUMMARY\n")
cat("========================================\n\n")

cat("DATASET:\n")
cat("  - Total genes analyzed:", nrow(res_df), "\n")
cat("  - Samples: Tumor (", sum(coldata_sub$condition == "tumor"), 
    ") vs Normal (", sum(coldata_sub$condition == "normal"), ")\n\n")

cat("DIFFERENTIAL EXPRESSION RESULTS (edgeR):\n")
cat("  - Significant DEGs (FDR < 0.05, |logFC| >= 1):", 
    sum(res_df$significance == "Significant", na.rm = TRUE), "\n")
cat("  - Upregulated in tumor:", 
    sum(res_df$direction == "Upregulated", na.rm = TRUE), "\n")
cat("  - Downregulated in tumor:", 
    sum(res_df$direction == "Downregulated", na.rm = TRUE), "\n\n")

cat("EFFECT SIZES:\n")
effect_stats <- res_df %>% 
  filter(significance == "Significant") %>%
  summarise(
    min_fc = min(logFC),
    max_fc = max(logFC),
    median_fc = median(logFC)
  )
cat("  - Largest upregulation: logFC =", round(effect_stats$max_fc, 2), 
    sprintf("(%.1f-fold)", 2^effect_stats$max_fc), "\n")
cat("  - Largest downregulation: logFC =", round(effect_stats$min_fc, 2),
    sprintf("(%.1f-fold)", 2^effect_stats$min_fc), "\n")
cat("  - Median absolute logFC:", round(median(abs(sig_genes$logFC)), 2), "\n\n")

cat("BIOLOGICAL SIGNIFICANCE:\n")
cat("  - ", round(100 * sum(res_df$significance == "Significant", na.rm = TRUE) / total_tested, 1),
    "% of genes are differentially expressed\n", sep = "")
cat("  - This indicates extensive transcriptional reprogramming\n")
cat("  - Consistent with hallmarks of cancer (proliferation, evasion, metabolism)\n\n")

cat("========================================\n")
```

## 8.2 Biological Context

The extensive differential expression observed reflects the complex molecular changes during lung adenocarcinoma development:

**Expected Biological Processes Affected:**

1.  **Cell Cycle & Proliferation**: Upregulated genes likely include cyclins, CDKs, and DNA replication machinery
2.  **Apoptosis Evasion**: Downregulation of pro-ap

# PART 2: PPI Network Analysis

This section implements the Protein-Protein Interaction analysis as
required by the project guidelines, replicating the logic of the
provided Python notebook.

## 2.1 Load and Clean PPI Data (HIPPIE)

We use the HIPPIE database. We filter for **high-confidence
interactions** ($\ge 0.65$) and clean the Entrez ID by removing prefixes
to prepare them for mapping.

```{r}
library(tidyverse)

# Loading of the downloaded HIPPI file
possible_paths <- c("data/HIPPIE-current.mitab.txt", "HIPPIE-current.mitab.txt")
found_path <- NULL

for (path in possible_paths) {
  if (file.exists(path)) {
    found_path <- path
    break
  }
}

if (is.null(found_path)) {
  stop("File not found")
} else {
  message(paste("File found in:", found_path))
}

# Loading data
hippie_cols <- c(
  "ID_Interactor_A", "ID_Interactor_B", "Alt_IDs_Interactor_A", "Alt_IDs_Interactor_B",
  "Aliases_Interactor_A", "Aliases_Interactor_B", "Interaction_Detection_Methods",
  "Publication_1st_Author", "Publication_Identifiers", "Taxid_Interactor_A", "Taxid_Interactor_B",
  "Interaction_Types", "Source_Databases", "Interaction_Identifiers", "Confidence_Value",
  "Presence_In_Other_Species", "Gene_Name_Interactor_A", "Gene_Name_Interactor_B"
)

hippie <- read_tsv(found_path, col_names = hippie_cols, comment = "#", show_col_types = FALSE)

# only confidence >= 0.65, other removed
edges_clean <- hippie %>%
  filter(Confidence_Value >= 0.65) %>%
  mutate(
    ID_Interactor_A = str_remove(ID_Interactor_A, "entrez gene:"),
    ID_Interactor_B = str_remove(ID_Interactor_B, "entrez gene:")
  ) %>%
  select(ID_Interactor_A, ID_Interactor_B, Confidence_Value)

cat("Interactions loaded (Score >= 0.65):", format(nrow(edges_clean), big.mark=","), "\n")
```

So we have a total of 207.294 interactions

## 2.2 Gene Annotation (NCBI Mapping)

To ensure data quality, we validate all HIPPIE interactions against the
**NCBI human gene database**. This filtering step is crucial to:

1.  **Remove interactions** involving deprecated or invalid gene
    identifiers.
2.  Ensure a **bidirectional mapping** between Entrez ID and Gene
    Symbols (so is like have an undirect graph.
3.  Guarantee the **biological relevance** of all protein interactions
    in the network.

We expect to retain the vast majority of interactions (\>99%) while
ensuring improved data integrity.

```{r part2_ncbi}
library(tidyverse)

# FILE LOCALI NCBI
ncbi_filename <- "Homo_sapiens.gene_info.gz"
possible_ncbi_paths <- c(paste0("data/", ncbi_filename), ncbi_filename)
found_ncbi_path <- NULL

for (path in possible_ncbi_paths) {
  if (file.exists(path)) {
    found_ncbi_path <- path
    break
  }
}

# Only columns that wre need
genes_ncbi <- read_tsv(found_ncbi_path, show_col_types = FALSE) %>%
  select(GeneID, Symbol, description) %>%
  mutate(GeneID = as.character(GeneID))

# keep interactions in the network where both genes are recognised
edges_final <- edges_clean %>%
  filter(ID_Interactor_A %in% genes_ncbi$GeneID & ID_Interactor_B %in% genes_ncbi$GeneID)

cat("Final Valid Interactions:", format(nrow(edges_final), big.mark=","), "\n")
```

As expected we lost only 1000 interactions, so less than 1%.

## 2.3 Network Construction and Analysis (igraph)

In this section, we construct the Protein-Protein Interaction (PPI)
network using the `igraph` package. To prepare the network for
topological analysis and propagation algorithms, we perform the
following steps:

1.  **Graph Creation:** We convert the cleaned edge list into an
    undirected graph structure.
2.  **Node Annotation:** We map the numeric Entrez IDs to human-readable
    Gene Symbols using the NCBI annotation loaded previously.
3.  **Simplification:** We remove self-loop. (proteins interacting with
    themselves) and duplicate edges to avoid statistical bias.
4.  **Giant Component Extraction:** We isolate the GCC, which is the
    largest cluster of connected nodes in the network.

**Why the Giant Component?** Algorithms like random walk with restart
(used in 2.5) require paths between nodes to function. Nodes isolated
from the main network cannot receive or transmit information during
propagation, so we focus our analysis on the largest connected subgraph.

```{r part2_network}
library(igraph)

# Graph construction (Network)
ppi_net <- graph_from_data_frame(d = edges_final, directed = FALSE)
# edges_final contains pairs of interacting genes

# add symbols to nodes in the network.
V(ppi_net)$symbol <- genes_ncbi$Symbol[match(V(ppi_net)$name, genes_ncbi$GeneID)]

# remove self-links and duplicates
ppi_net <- simplify(ppi_net, remove.multiple = TRUE, remove.loops = TRUE)

# extraction of Giant Component
comps <- components(ppi_net)
giant_id <- which.max(comps$csize)
giant_component <- induced_subgraph(ppi_net, which(comps$membership == giant_id))

cat("Nodes:", format(vcount(giant_component), big.mark=","), "\n")

```

So after the computation we have a graph with 15.836 nodes, which are
the nodes linked by the 206.515 arcs (interactions).

## 2.4 Topology Analysis: Hub Identification

In this section, we analyze the structural properties of the network.
Specifically, we calculate the degree (number of connections) for each
node to:

1.  **Verify the Scale-Free Nature:** Biological networks typically
    follow a power-law distribution, where most nodes have few
    connections, but a few "hubs" have hundreds or thousands. So the
    best way to visualize this is using a log-log plot, for bettere
    understanding.
2.  **Identify Hub Genes:** We extract the top 15 most connected
    proteins. These hubs are often biologically essential and serve as
    central communication points in cellular signaling.

```{r part2_hubs, fig.width=8, fig.height=5}
library(ggplot2)
library(knitr)
library(dplyr)

# 1. Calculation of degree (n connections x node)
node_degrees <- degree(giant_component)
deg_df <- data.frame(GeneID = names(node_degrees), Degree = node_degrees)

# 2. Grade sitribution chart (log-log Scale)
ggplot(deg_df, aes(x = Degree)) +
  geom_histogram(bins = 50, fill = "darkblue", color = "white", alpha=0.8) +
  scale_y_log10() + 
  scale_x_log10() +
  labs(title = "degree distribution (log-log Scale)", 
       subtitle = "Network Topology Analysis",
       x = "Degree (k)", y = "Frequency P(k)") +
  theme_minimal()

# 3. identification ofi Top 15 Hubs
top_hubs <- deg_df %>%
  arrange(desc(Degree)) %>%
  head(15) %>%
  left_join(genes_ncbi, by = "GeneID") %>%
  select(Symbol, Degree, description)

kable(top_hubs, caption = "Top 15 Hub Genes identified in the Network")
```

We calculate the degree distribution to confirm the scale-free nature of
the network and identify the most connected proteins (Hubs).

The analysis of the network topology provides two key insights into the
biological system under study:

#### 1. Scale-Free Architecture

The **Degree Distribution plot**displays a clear downward trend. This
confirms that our PPI network is **scale-free**, a typical property of
biological networks.

**Implication:** The network is dominated by a small number of highly
connected nodes (**Hubs**), while the vast majority of proteins have few
interactions. This structure makes the cellular network robust against
random failures but vulnerable to the targeted disruption of these
specific hubs.

#### 2. Biological Relevance of Top Hubs

-   **Cancer Drivers & Signaling:**
    -   **TP53 (750 links):** The "guardian of the genome," frequently
        mutated in lung cancer. Its high connectivity reflects its
        central role in deciding cell fate (repair vs. apoptosis).
    -   **EGFR (564 links):** A major driver in Lung Adenocarcinoma. The
        presence of EGFR as a top hub is particularly significant for
        this dataset, as EGFR mutations are a primary therapeutic target
        in LUAD.
    -   **MYC (766 links):** A well-known proto-oncogene that regulates
        cell growth and is often dysregulated in tumors.
    -   **ESR1 (1963 links):** The top hub. While primarily an estrogen
        receptor, it acts as a massive signal integrator in various
        tissues.
-   **Structural & Maintenance Machinery:**
    -   **CUL3, CUL1, COPS5, SUMO2:** These proteins are part of the
        Ubiquitin-Proteasome System. They are responsible for protein
        degradation and turnover. It is expected for them to be hubs
        because they physically interact with thousands of other
        proteins to "tag" them for recycling.

**Conclusion:** The presence of known lung cancer drivers (TP53, EGFR)
alongside essential cellular machinery (CUL3, UBC) confirms that the
network reconstruction was successful and biologically meaningful.

## 2.5 Network Propagation (Random Walk with Restart)

In this step, we implement the **Random Walk with Restart (RWR)**
algorithm to identify "hidden" disease genes. While Differential
Expression (DE) analysis identifies genes with altered mRNA levels, it
often misses key signaling proteins (like kinases or transcription
factors) whose activity changes due to phosphorylation or complex
formation rather than expression changes.

We use the network topology to find these genes based on the
Guilt-by-Association principle: "genes that are topologically close to
the known disease genes are likely involved in the same pathological
process".

**Algorithm Steps:** 1. **Define Seeds:** We load the differentially
expressed genes (FDR \< 0.05) from the LUAD analysis and map them to the
network. These act as the "Seeds" or start points. 2. **Personalized
PageRank:** We use the page_rank algorithm (an implementation of RWR).
\* **Restart Probability (**$r = 1 - d$): We set the damping factor
$d = 0.85$. This means the "random walker" has an 85% chance of moving
to a neighbor and a 15% chance of jumping back to the seed genes. 3.
**Scoring:** Each gene receives a score representing its proximity to
the seeds. 4. **Novel Discovery:** We remove the original seed genes
from the results to identify **New Candidates**—high-scoring genes that
were *not* differentially expressed but are structurally central to the
disease module.

```{r part2_propagation}
library(igraph)

# 1. load the file CSV 
de_results <- read.csv("results_de_genes_LUAD_edgeR.csv")

# 2. Filter significant genes (padj < 0.05)
de_results_filtered <- de_results %>%
  filter(!is.na(entrez_id)) %>%
  filter(FDR < 0.05)#
disease_gene_ids <- as.character(de_results_filtered$entrez_id)

# 3. Ensure that these genes are present in the network
disease_gene_ids <- intersect(disease_gene_ids, V(giant_component)$name)
# CHECK: nessun gene nel debug
if (length(disease_gene_ids) == 0) {
  stop("ERRORE: Nessun gene DE trovato nella rete PPI!")
}

# ALGORITHM EXECUTION RW
personalized_vector <- rep(0, length(V(giant_component)))
names(personalized_vector) <- V(giant_component)$name
personalized_vector[disease_gene_ids] <- 1
personalized_vector <- personalized_vector / sum(personalized_vector)

# 85% prob restart
rwr_scores <- page_rank(
  giant_component, 
  directed = FALSE, 
  damping = 0.85, 
  personalized = personalized_vector
)$vector

results_df <- data.frame(
  GeneID = names(rwr_scores),
  Score = rwr_scores,
  Symbol = V(giant_component)$symbol
) %>%
  arrange(desc(Score))

# identify NEW candidates
# (High-scoring genes that were NOT on the initial list of diseased genes, the ones from LAUD.csv)
new_candidates <- results_df %>%
  filter(!GeneID %in% disease_gene_ids) %>%
  head(100) # Prendiamo i top 100

cat("Top 10 new candidates identified by Network Propagation:\n")
kable(head(new_candidates[, c("Symbol", "Score")], 10))
```

### Analysis of Top Predicted Candidates

The top 10 candidates identified by the Random Walk with Restart (RWR)
algorithm provide a compelling validation of the network-based approach.

**Observations:**

1.  **Rediscovery of Known Drivers (The "False Negative" Recovery):**
    -   Crucially, **TP53**, **EGFR**, and **MYC** appear as top
        predicted candidates.
    -   These are well-established drivers of Lung Adenocarcinoma. Their
        absence in the initial Differential Expression (DE) results
        (likely due to strict FDR thresholds or non-transcriptional
        regulation) highlights the limitation of pure RNA-seq analysis.
    -   The network propagation successfully "recovered" these key
        genes, proving that they are central to the disease mechanism
        even if their expression levels are not statistically
        significantly altered.
2.  **Hub Bias and Structural Integrity:**
    -   Genes like **ESR1** and **CUL3** appear at the very top. While
        biologically relevant (CUL3 is involved in protein degradation,
        a process often hijacked in cancer), their high rank is partly
        due to their extreme connectivity (Hubs).
    -   However, the co-occurrence of specific lung cancer markers
        (EGFR) alongside these global hubs suggests that the algorithm
        is correctly identifying the disease neighborhood.

**Conclusion:** The RWR algorithm successfully expanded the list of
potential targets, identifying "hidden" players that would have been
missed by standard differential expression analysis alone.

### 2.5b Enriched Disease Module Visualization

```{r}
library(igraph)
library(dplyr)

# Get top 13 genes 
top_13_genes <- results_df %>% head(13) %>% pull(GeneID)
enriched_subgraph <- induced_subgraph(giant_component, top_13_genes)

V(enriched_subgraph)$type <- ifelse(V(enriched_subgraph)$name %in% disease_gene_ids, 
                                     "Seed", "Predicted")
V(enriched_subgraph)$label <- V(enriched_subgraph)$symbol

cat("Enriched Module - Top 13 Hub Genes:\n")
cat("Nodes:", vcount(enriched_subgraph), "\n")
cat("Edges:", ecount(enriched_subgraph), "\n\n")

# Layout
set.seed(123)
layout <- layout_with_fr(enriched_subgraph, 
                         niter = 1500,
                         start.temp = 150)
layout <- layout * 30

colors <- ifelse(V(enriched_subgraph)$type == "Seed", "red", "lightblue")
sizes <- (degree(enriched_subgraph) + 1) * 3.5

plot(enriched_subgraph,
     vertex.size = sizes,
     vertex.color = colors,
     vertex.label.cex = 1.2,
     vertex.label.dist = 1,
     vertex.label.family = "sans",
     edge.width = 2,
     edge.color = rgb(0, 0, 0, 0.2),
     main = "Enriched Disease Module - Top 13 Hub Genes",
     sub = "Red: DE genes (seed) | Blue: Network candidates",
     layout = layout)

legend("topright", 
       legend = c("Seed (DE gene)", "Predicted candidate"),
       col = c("red", "lightblue"),
       pch = 19,
       cex = 1.2,
       pt.cex = 2)
```

The enriched disease module visualization displays the top 13
highest-scoring genes from the RWR analysis.

**Red Nodes:** Seed genes (known Differentially Expressed genes from the
LUAD dataset). **Blue Nodes:** Novel candidates predicted by network
propagation (not originally DE, but functionally linked).

**Key Findings:**

-   **PCNA as a Central Anchor:** PCNA emerges as the primary seed gene
    connecting the module. As a key factor in DNA replication, its
    **dysregulation** is a hallmark of tumor proliferation.

-   **Recovery of Key Drivers:** **TP53**, **MYC**, and **EGFR** appear
    ss predicted candidates (blue). Their strong connection to PCNA
    suggests they drive the proliferative state even without being
    differentially expressed themselves.

-   **Functional Implications:** The tight clustering suggests a
    breakdown in **cell cycle control** and **DNA repair mechanisms**.
    **Therapeutic Targets:** Hub proteins like **EGFR** and **HSPA8**
    (Heat Shock Protein) represent potential drug targets within this
    complex.

*Note:* PCNA appears here (despite being excluded from the "New
Candidates" table) because this graph shows the *absolute* top-ranking
nodes to visualize the complete disease mechanism, including the
original triggers (Seeds).\

## 2.6 Functional Enrichment Analysis

We perform pathway enrichment analysis on the top 100 predicted genes
using `gprofiler2` to understand their biological functions (GO, KEGG,
Reactome).

```{r part2_enrichment, fig.width=10, fig.height=8}
library(gprofiler2)

# Enrichment
gostres <- gost(query = new_candidates$Symbol, 
                organism = "hsapiens", 
                ordered_query = TRUE, 
                significant = TRUE,
                sources = c("GO:BP", "KEGG", "REAC"))

if (!is.null(gostres$result)) {
  # 1. Manhattan Plot 
  p <- gostplot(gostres, capped = FALSE, interactive = FALSE)
  print(p)
  
  # 2. Top Pathway
  top_pathways <- gostres$result %>%
    select(source, term_name, p_value, intersection_size) %>%
    arrange(p_value) %>%
    head(15)
    
  kable(top_pathways, caption = "Top Enriched Pathways for Predicted Genes")
} else {
  cat("No significant enrichment found (likely due to random simulated data).\n")
}
```

We perform pathway enrichment analysis on the top 100 predicted genes
identified by network propagation using g:Profiler2. This analysis
integrates three major pathway databases: Gene Ontology Biological
Processes (<GO:BP>), KEGG pathways, and Reactome.

### Manhattan Plot Interpretation

The Manhattan plot visualizes the statistical significance of pathway
enrichments across different sources:

-   **Orange points (<GO:BP>)**: Gene Ontology biological processes
    dominate the results, reflecting the detailed functional annotations
    available in this database.
-   **Pink points (KEGG)**: Metabolic and signaling pathways, showing
    intermediate significance levels.
-   **Blue points (REAC)**: Reactome pathways with the highest
    statistical significance (p-value \< 0.001), indicating robust
    biological relevance.

### Key Enriched Pathways

The top 15 enriched pathways reveal strong biological relevance:

**Cell Death and Apoptosis (p-value = 0):** - Programmed cell death (51
genes) - Apoptotic process (49 genes) - Cell death (51 genes)

These pathways are highly dysregulated in lung cancer. LUAD cells evade
apoptosis through alterations in TP53, EGFR, and other predicted hub
genes.

**Metabolic Regulation (p-value = 0):** - Regulation of protein
metabolic process (53 genes) - Regulation of primary metabolic process
(77 genes) - Positive regulation of macromolecule metabolic process (66
genes)

PCNA and predicted hub proteins regulate DNA replication machinery and
metabolic reprogramming in cancer cells.

**Signal Transduction and Stress Response:** - Intracellular signal
transduction (59 genes) - Cellular response to stress (47 genes)

These pathways highlight the dysregulation of growth signaling and
cellular stress responses in LUAD.

**Reactome Disease Pathway (p-value = 0):** - 64 genes directly
annotated as disease-associated, providing direct validation that our
network propagation identified clinically relevant genes.

### Conclusion

The comprehensive enrichment analysis strongly validates the biological
relevance of the network-predicted candidates. The convergence of
multiple pathway databases on cancer-relevant processes (apoptosis,
metabolic regulation, signal transduction) confirms that random walk
with restart successfully identified genes involved in lung
adenocarcinoma pathogenesis.
